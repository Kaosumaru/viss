# Copilot Instructions for Viss

## Project Overview

Viss is a visual shader editor for WebGL that allows users to create GLSL shaders through a node-based graph interface. The project consists of:

- A web application built with React, TypeScript, and Vite
- A VS Code extension that provides a custom editor for `.viss` files
- A shader compiler that converts node graphs to GLSL code

## Architecture

### Project Structure

```
src/
├── compiler/          # GLSL compiler and graph processing
│   ├── compiler/      # Core compiler logic
│   ├── glsl/          # GLSL parsing and code generation
│   └── graph/         # Graph data structures
├── renderer/          # React UI components
│   ├── components/    # UI components (uniforms, includes, nodes)
│   ├── graph/         # Rete.js integration
│   └── vscode/        # VS Code extension communication
└── main.tsx           # Application entry point

vscode-extension/      # VS Code extension
├── src/               # Extension code
└── media/             # Built web app assets
```

### Key Components

1. **Compiler** (`@compiler`): Converts node graphs to GLSL code

   - Manages node compilation, type checking, and GLSL generation
   - Handles connections, parameters, and uniforms
   - Supports custom functions from GLSL files

2. **Renderer** (`@renderer`): React UI for the visual editor

   - Uses Rete.js for node graph editing
   - Provides shader preview with WebGL
   - Manages uniforms, includes, and node properties

3. **VS Code Extension**: Custom editor provider for `.viss` files
   - Communicates with webview via message passing
   - Handles file I/O and workspace integration

## Code Style and Conventions

### TypeScript

- Use strict TypeScript (`strictTypeChecked` ESLint config)
- Prefer `type` over `interface` for type definitions
- Use path aliases: `@compiler`, `@renderer`, `@glsl`, `@graph`, `@test`
- Avoid `any` types; use proper type definitions
- Use `Omit`, `Pick`, and utility types for type transformations

### Naming Conventions

- Files: camelCase for utilities, PascalCase for components
- Components: PascalCase (e.g., `FloatUniformItem.tsx`)
- Functions/variables: camelCase
- Types/Interfaces: PascalCase
- Constants: UPPER_SNAKE_CASE only for true constants

### React

- Use functional components with hooks
- Use Material-UI (MUI) for UI components
- Follow existing component patterns in `src/renderer/components/`
- Use context for shared state (e.g., `EditorContext`)

### Imports

- Group imports: external packages, then internal modules
- Use path aliases consistently
- Avoid circular dependencies

## Development Workflow

### Setup

```bash
npm install
```

### Build and Test

```bash
npm run dev              # Start development server
npm run build:web        # Build web application
npm run build:vscode     # Build VS Code extension
npm run lint             # Run ESLint
npm run check-types      # Run TypeScript type checking
npm run test             # Run Vitest tests
```

### VS Code Extension Development

1. Build the web app: `npm run build:vscode`
2. Open `vscode-extension/` in VS Code
3. Press F5 to launch extension development host
4. Open a `.viss` file to test

## Testing Guidelines

- Use Vitest for unit tests
- Place tests next to the code: `*.test.ts` or `*.test.tsx`
- Focus on compiler logic, type conversions, and node compilation
- Use `expect` from Vitest for assertions
- Example test locations:
  - `src/compiler/glsl/function.test.ts`
  - `src/compiler/compiler/nodes/operators/*.test.ts`

### Test Structure

```typescript
import { expect, test } from "vitest";
import { functionToTest } from "./module";

test("description of what is being tested", () => {
  const result = functionToTest(input);
  expect(result).toEqual(expectedOutput);
});
```

## Rete.js Integration

For Rete.js development, reference the documentation at:
https://retejs.org/llms-full.txt

Focus on:

- Node editor patterns and dataflow programming
- Plugin architecture (rete-area-plugin, rete-connection-plugin, etc.)
- Custom node components and sockets
- Connection validation and type checking

## GLSL and Shader Compilation

### Custom Functions

- Use `#pragma editor: export` to export GLSL functions as nodes
- Functions are parsed using `@shaderfrog/glsl-parser`
- Type system supports scalars, vectors, matrices, and samplers

### Type System

- Types are defined in `@glsl/types/types.ts`
- Use helpers: `scalar()`, `vector()`, `matrix()`, `sampler2D()`
- Type conversions are handled in `@glsl/types/implicitConversion.ts`

## Common Patterns

### Adding a New Node Type

1. Create node class in `src/compiler/compiler/nodes/`
2. Extend `CompilerNode` base class
3. Implement `compile()` method to generate GLSL
4. Define sockets and parameters
5. Register in node factory/registry

### Adding a Uniform Visualizer

1. Create component in `src/renderer/components/uniforms/`
2. Add entry to `uniformVisualizers` array in `entries.ts`
3. Add component to `uniformComponents` map
4. Implement `UniformItemProps` interface

### VS Code Extension Communication

- Use message passing between extension and webview
- Messages defined in `vscode-extension/src/messages/messages.ts`
- Extension -> Webview: `postMessage(webviewPanel, message)`
- Webview -> Extension: `window.acquireVsCodeApi().postMessage()`

## Important Constraints

1. **React Version**: Must use `--legacy-peer-deps` due to rete-react-plugin peer dependency
2. **Path Aliases**: Always use configured aliases (`@compiler`, etc.) for imports
3. **Type Safety**: Maintain strict TypeScript; avoid `any` types
4. **GLSL Validation**: Ensure generated GLSL is valid and type-safe
5. **VSCode API**: Use VS Code API carefully; test in extension development host

## Common Gotchas

- The compiler uses a stack-based approach; understand node dependencies before modifying
- Rete.js connections trigger recompilation; avoid unnecessary updates
- GLSL includes are added globally; watch for duplicate includes
- Parameter values have different representations (editor vs. runtime)
- Type conversions follow GLSL implicit conversion rules

## Build Modes

- `production`: Web application for GitHub Pages (base path: `/viss/`)
- `vscode-extension`: Builds for VS Code extension (single entry file)
- Use `__VSCODE_EXTENSION__` flag to conditionally enable features

## Additional Resources

- [Rete.js Documentation](https://retejs.org/llms-full.txt)
- [GLSL Specification](https://www.khronos.org/opengl/wiki/OpenGL_Shading_Language)
- [VS Code Extension API](https://code.visualstudio.com/api)
